<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Leon – Weight History</title>
  <script src="https://cdn.plot.ly/plotly-2.30.0.min.js"></script>
  <style>
    body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Arial, sans-serif; margin: 0; padding: 16px; }
    .wrap { max-width: 980px; margin: 0 auto; }
    h1 { font-size: 18px; margin: 0 0 10px 0; }
    #chart { height: 520px; }
    .controls { display: flex; gap: 10px; align-items: end; flex-wrap: wrap; margin: 10px 0 6px; }
    .control { display: flex; flex-direction: column; gap: 6px; }
    label { font-size: 12px; color: #333; }
    input[type="date"] { padding: 8px 10px; font-size: 14px; }
    .out { font-size: 14px; padding: 8px 10px; border: 1px solid #ddd; border-radius: 8px; min-width: 260px; }
    .hint { font-size: 12px; color: #666; margin-top: 6px; }
    .note { font-size: 12px; color: #666; margin-top: 10px; }
    code { background: #f5f5f5; padding: 1px 6px; border-radius: 6px; }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Weight history (hover for exact values). Pick any date to estimate.</h1>
    <div class="controls">
      <div class="control">
        <label for="d">Estimate for date</label>
        <input id="d" type="date" />
      </div>
      <div class="control">
        <label>Estimated weight</label>
        <div id="out" class="out">Choose a date…</div>
      </div>
    </div>
    <div id="chart"></div>
    <div class="note">
      Estimation uses straight-line interpolation between your nearest logged weigh-ins.
      If the chosen date is outside your data range, it returns the closest recorded value.
    </div>
  </div>

<script>
  const data = [{"date": "2019-07-29", "weight": 80.0}, {"date": "2019-09-10", "weight": 82.4}, {"date": "2019-09-27", "weight": 80.7}, {"date": "2019-09-30", "weight": 80.7}, {"date": "2020-04-08", "weight": 80.7}, {"date": "2020-06-02", "weight": 80.7}, {"date": "2020-06-04", "weight": 77.0}, {"date": "2020-09-22", "weight": 73.0}, {"date": "2020-10-03", "weight": 72.0}, {"date": "2020-10-06", "weight": 74.0}, {"date": "2021-07-21", "weight": 81.0}, {"date": "2021-08-25", "weight": 82.0}, {"date": "2021-08-31", "weight": 79.0}, {"date": "2022-06-17", "weight": 84.6}, {"date": "2024-01-05", "weight": 82.0}, {"date": "2025-01-11", "weight": 87.0}, {"date": "2025-08-31", "weight": 91.0}, {"date": "2025-09-01", "weight": 89.7}, {"date": "2025-09-10", "weight": 88.9}, {"date": "2025-10-01", "weight": 88.2}, {"date": "2025-12-24", "weight": 92.0}, {"date": "2025-12-26", "weight": 89.4}, {"date": "2025-12-27", "weight": 89.0}, {"date": "2025-12-29", "weight": 89.0}, {"date": "2025-12-30", "weight": 88.9}, {"date": "2025-12-31", "weight": 88.7}, {"date": "2026-01-01", "weight": 90.0}, {"date": "2026-01-02", "weight": 88.4}, {"date": "2026-01-06", "weight": 90.0}, {"date": "2026-01-10", "weight": 89.0}, {"date": "2026-01-11", "weight": 88.3}, {"date": "2026-01-13", "weight": 88.3}, {"date": "2026-01-19", "weight": 89.0}, {"date": "2026-01-22", "weight": 88.3}, {"date": "2026-01-24", "weight": 87.1}, {"date": "2026-01-25", "weight": 87.4}, {"date": "2026-01-26", "weight": 86.8}, {"date": "2026-01-29", "weight": 86.7}, {"date": "2026-01-30", "weight": 86.5}, {"date": "2026-01-31", "weight": 86.5}, {"date": "2026-02-01", "weight": 86.7}, {"date": "2026-02-02", "weight": 87.1}, {"date": "2026-02-03", "weight": 87.2}, {"date": "2026-02-05", "weight": 86.8}, {"date": "2026-02-06", "weight": 86.3}, {"date": "2026-02-07", "weight": 84.4}, {"date": "2026-02-08", "weight": 85.5}, {"date": "2026-02-12", "weight": 85.9}, {"date": "2026-02-14", "weight": 84.9}];

  const xs = data.map(r => r.date);
  const ys = data.map(r => r.weight);

  function parseDate(s) {
    const [y,m,d] = s.split('-').map(Number);
    return new Date(Date.UTC(y, m-1, d));
  }

  const pts = data.map(r => ({ t: parseDate(r.date).getTime(), w: r.weight, d: r.date })).sort((a,b)=>a.t-b.t);

  function estimate(dateStr) {
    if (!dateStr) return null;
    const t = parseDate(dateStr).getTime();
    if (t <= pts[0].t) return { w: pts[0].w, a: pts[0], b: pts[0], mode: "clamped" };
    if (t >= pts[pts.length-1].t) return { w: pts[pts.length-1].w, a: pts[pts.length-1], b: pts[pts.length-1], mode: "clamped" };

    // find right index
    let lo = 0, hi = pts.length - 1;
    while (lo + 1 < hi) {
      const mid = Math.floor((lo + hi) / 2);
      if (pts[mid].t <= t) lo = mid; else hi = mid;
    }
    const a = pts[lo], b = pts[hi];
    const frac = (t - a.t) / (b.t - a.t);
    const w = a.w + frac * (b.w - a.w);
    return { w, a, b, mode: "interp" };
  }

  const trace = {
    x: xs,
    y: ys,
    mode: 'lines+markers',
    name: 'Weight (kg)',
    hovertemplate: '%{x}<br>%{y:.1f} kg<extra></extra>'
  };

  const layout = {
    margin: {l: 50, r: 20, t: 20, b: 50},
    xaxis: { title: 'Date', type: 'date' },
    yaxis: { title: 'kg', rangemode: 'tozero' },
    hovermode: 'x',
    shapes: []
  };

  Plotly.newPlot('chart', [trace], layout, {displaylogo: false, responsive: true});

  const input = document.getElementById('d');
  const out = document.getElementById('out');

  // default date: latest
  input.min = pts[0].d;
  input.max = pts[pts.length-1].d;
  input.value = pts[pts.length-1].d;

  function setLine(dateStr) {
    const est = estimate(dateStr);
    if (!est) return;
    const w = est.w;
    const line = {
      type: 'line',
      xref: 'x',
      yref: 'paper',
      x0: dateStr,
      x1: dateStr,
      y0: 0,
      y1: 1,
      line: { width: 2, dash: 'dot' }
    };
    Plotly.relayout('chart', { shapes: [line] });

    if (est.mode === "interp") {
      out.textContent = `${w.toFixed(1)} kg (between ${est.a.d} ${est.a.w.toFixed(1)} kg and ${est.b.d} ${est.b.w.toFixed(1)} kg)`;
    } else {
      out.textContent = `${w.toFixed(1)} kg (closest recorded value)`;
    }
  }

  input.addEventListener('input', (e) => setLine(e.target.value));
  setLine(input.value);
</script>
</body>
</html>
